<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang='en'>
<head>
<title>epdconfig.py</title>
<meta content='text/html; charset=UTF-8' http-equiv='Content-Type'>
<link href='../../../css/style.css' media='screen' rel='stylesheet' type='text/css'>
<script type='text/javascript'>
  function popupCode(url) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }
  
  function toggleCode(id) {
    var code = document.getElementById(id)
  
    code.style.display = code.style.display != 'block' ? 'block' : 'none'
    return true
  }
  
  // Make codeblocks hidden by default
  document.writeln('<' + 'style type="text/css">.method .source pre { display: none }<\/style>')
</script>
</head>
<body class='page'>
<div class='file' id='wrapper'>
<div class='header'>
<h1 class='name'>epdconfig.py
</h1>
<div class='paths'>
vendor/waveshare_epd/epdconfig.py
</div>
<div class='last-update'>
Last Update:
<span class='datetime'>2020-04-02 15:37:35 -0700</span>
</div>
</div>
<div id='content'>
<div id='text'>
<div id='description'>
<p># /***************************************************************************** # * | File        :       epdconfig.py # * | Author      :   Waveshare team # * | Function    :   Hardware underlying interface # * | Info        : # *—————- # * | This version:   V1.0 # * | Date        :   2019-06-21 # * | Info        :</p>

<p># ****************************************************************************** # Permission is hereby granted, free of charge, to any person obtaining a copy # of this software and associated documnetation files (the “Software”), to deal # in the Software without restriction, including without limitation the rights # to use, copy, modify, merge, publish, distribute, sublicense, and/or sell # copies of the Software, and to permit persons to  whom the Software is # furished to do so, subject to the following conditions: # # The above copyright notice and this permission notice shall be included in # all copies or substantial portions of the Software. # # THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR # IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, # FITNESS OR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE # AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER # LIABILITY WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN # THE SOFTWARE. #</p>

<p>import os import logging import sys import time</p>

<p>class RaspberryPi:</p>

<pre># Pin definition&#x000A;RST_PIN         = 17&#x000A;DC_PIN          = 25&#x000A;CS_PIN          = 8&#x000A;BUSY_PIN        = 24&#x000A;def __init__(self):&#x000A;    import spidev&#x000A;    import RPi.GPIO&#x000A;&#x000A;    self.GPIO = RPi.GPIO&#x000A;&#x000A;    # SPI device, bus = 0, device = 0&#x000A;    self.SPI = spidev.SpiDev(0, 0)&#x000A;&#x000A;def digital_write(self, pin, value):&#x000A;    self.GPIO.output(pin, value)&#x000A;&#x000A;def digital_read(self, pin):&#x000A;    return self.GPIO.input(pin)&#x000A;&#x000A;def delay_ms(self, delaytime):&#x000A;    time.sleep(delaytime / 1000.0)&#x000A;&#x000A;def spi_writebyte(self, data):&#x000A;    self.SPI.writebytes(data)&#x000A;&#x000A;def module_init(self):&#x000A;    self.GPIO.setmode(self.GPIO.BCM)&#x000A;    self.GPIO.setwarnings(False)&#x000A;    self.GPIO.setup(self.RST_PIN, self.GPIO.OUT)&#x000A;    self.GPIO.setup(self.DC_PIN, self.GPIO.OUT)&#x000A;    self.GPIO.setup(self.CS_PIN, self.GPIO.OUT)&#x000A;    self.GPIO.setup(self.BUSY_PIN, self.GPIO.IN)&#x000A;    self.SPI.max_speed_hz = 4000000&#x000A;    self.SPI.mode = 0b00&#x000A;    return 0&#x000A;&#x000A;def module_exit(self):&#x000A;    logging.debug(&quot;spi end&quot;)&#x000A;    self.SPI.close()&#x000A;&#x000A;    logging.debug(&quot;close 5V, Module enters 0 power consumption ...&quot;)&#x000A;    self.GPIO.output(self.RST_PIN, 0)&#x000A;    self.GPIO.output(self.DC_PIN, 0)&#x000A;&#x000A;    self.GPIO.cleanup()</pre>

<p>class JetsonNano:</p>

<pre># Pin definition&#x000A;RST_PIN         = 17&#x000A;DC_PIN          = 25&#x000A;CS_PIN          = 8&#x000A;BUSY_PIN        = 24&#x000A;def __init__(self):&#x000A;    import ctypes&#x000A;    find_dirs = [&#x000A;        os.path.dirname(os.path.realpath(__file__)),&#x000A;        &#39;/usr/local/lib&#39;,&#x000A;        &#39;/usr/lib&#39;,&#x000A;    ]&#x000A;    self.SPI = None&#x000A;    for find_dir in find_dirs:&#x000A;        so_filename = os.path.join(find_dir, &#39;sysfs_software_spi.so&#39;)&#x000A;        if os.path.exists(so_filename):&#x000A;            self.SPI = ctypes.cdll.LoadLibrary(so_filename)&#x000A;            break&#x000A;    if self.SPI is None:&#x000A;        raise RuntimeError(&#39;Cannot find sysfs_software_spi.so&#39;)&#x000A;&#x000A;    import Jetson.GPIO&#x000A;    self.GPIO = Jetson.GPIO&#x000A;&#x000A;def digital_write(self, pin, value):&#x000A;    self.GPIO.output(pin, value)&#x000A;&#x000A;def digital_read(self, pin):&#x000A;    return self.GPIO.input(self.BUSY_PIN)&#x000A;&#x000A;def delay_ms(self, delaytime):&#x000A;    time.sleep(delaytime / 1000.0)&#x000A;&#x000A;def spi_writebyte(self, data):&#x000A;    self.SPI.SYSFS_software_spi_transfer(data[0])&#x000A;&#x000A;def module_init(self):&#x000A;    self.GPIO.setmode(self.GPIO.BCM)&#x000A;    self.GPIO.setwarnings(False)&#x000A;    self.GPIO.setup(self.RST_PIN, self.GPIO.OUT)&#x000A;    self.GPIO.setup(self.DC_PIN, self.GPIO.OUT)&#x000A;    self.GPIO.setup(self.CS_PIN, self.GPIO.OUT)&#x000A;    self.GPIO.setup(self.BUSY_PIN, self.GPIO.IN)&#x000A;    self.SPI.SYSFS_software_spi_begin()&#x000A;    return 0&#x000A;&#x000A;def module_exit(self):&#x000A;    logging.debug(&quot;spi end&quot;)&#x000A;    self.SPI.SYSFS_software_spi_end()&#x000A;&#x000A;    logging.debug(&quot;close 5V, Module enters 0 power consumption ...&quot;)&#x000A;    self.GPIO.output(self.RST_PIN, 0)&#x000A;    self.GPIO.output(self.DC_PIN, 0)&#x000A;&#x000A;    self.GPIO.cleanup()</pre>

<p>if os.path.exists(&#39;/sys/bus/platform/drivers/gpiomem-bcm2835&#39;):</p>

<pre class="ruby"><span class="ruby-identifier">implementation</span> = <span class="ruby-constant">RaspberryPi</span>()</pre>

<p>else:</p>

<pre class="ruby"><span class="ruby-identifier">implementation</span> = <span class="ruby-constant">JetsonNano</span>()</pre>

<p>for func in [x for x in dir(implementation) if not x.startswith(&#39;_&#39;)]:</p>

<pre class="ruby"><span class="ruby-identifier">setattr</span>(<span class="ruby-identifier">sys</span>.<span class="ruby-identifier">modules</span>[<span class="ruby-identifier">__name__</span>], <span class="ruby-identifier">func</span>, <span class="ruby-identifier">getattr</span>(<span class="ruby-identifier">implementation</span>, <span class="ruby-identifier">func</span>))</pre>

<p>### END OF FILE ###</p>
</div>
<div id='context'>
</div>

</div>
</div>

<div id='footer-push'></div>
</div>
<div id='footer'>
<a href="https://github.com/rdoc/hanna-nouveau"><strong>Hanna Nouveau</strong> RDoc template</a>
</div>
</body>
</html>
