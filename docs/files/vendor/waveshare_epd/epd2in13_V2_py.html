<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang='en'>
<head>
<title>epd2in13_V2.py</title>
<meta content='text/html; charset=UTF-8' http-equiv='Content-Type'>
<link href='../../../css/style.css' media='screen' rel='stylesheet' type='text/css'>
<script type='text/javascript'>
  function popupCode(url) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }
  
  function toggleCode(id) {
    var code = document.getElementById(id)
  
    code.style.display = code.style.display != 'block' ? 'block' : 'none'
    return true
  }
  
  // Make codeblocks hidden by default
  document.writeln('<' + 'style type="text/css">.method .source pre { display: none }<\/style>')
</script>
</head>
<body class='page'>
<div class='file' id='wrapper'>
<div class='header'>
<h1 class='name'>epd2in13_V2.py
</h1>
<div class='paths'>
vendor/waveshare_epd/epd2in13_V2.py
</div>
<div class='last-update'>
Last Update:
<span class='datetime'>2020-03-03 21:32:22 -0800</span>
</div>
</div>
<div id='content'>
<div id='text'>
<div id='description'>
<p># ***************************************************************************** # * | File        :       epd2in13_V2.py # * | Author      :   Waveshare team # * | Function    :   Electronic paper driver # * | Info        : # *—————- # * | This version:   V4.0 # * | Date        :   2019-06-20 # # | Info        :   python demo # —————————————————————————– # Permission is hereby granted, free of charge, to any person obtaining a copy # of this software and associated documnetation files (the “Software”), to deal # in the Software without restriction, including without limitation the rights # to use, copy, modify, merge, publish, distribute, sublicense, and/or sell # copies of the Software, and to permit persons to  whom the Software is # furished to do so, subject to the following conditions: # # The above copyright notice and this permission notice shall be included in # all copies or substantial portions of the Software. # # THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR # IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, # FITNESS OR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE # AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER # LIABILITY WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN # THE SOFTWARE. #</p>

<p>import logging from . import epdconfig import numpy as np</p>

<p># Display resolution EPD_WIDTH       = 122 EPD_HEIGHT      = 250</p>

<p>class EPD:</p>

<pre>def __init__(self):&#x000A;    self.reset_pin = epdconfig.RST_PIN&#x000A;    self.dc_pin = epdconfig.DC_PIN&#x000A;    self.busy_pin = epdconfig.BUSY_PIN&#x000A;    self.cs_pin = epdconfig.CS_PIN&#x000A;    self.width = EPD_WIDTH&#x000A;    self.height = EPD_HEIGHT&#x000A;FULL_UPDATE = 0&#x000A;PART_UPDATE = 1&#x000A;lut_full_update= [&#x000A;    0x80,0x60,0x40,0x00,0x00,0x00,0x00,             #LUT0: BB:     VS 0 ~7&#x000A;    0x10,0x60,0x20,0x00,0x00,0x00,0x00,             #LUT1: BW:     VS 0 ~7&#x000A;    0x80,0x60,0x40,0x00,0x00,0x00,0x00,             #LUT2: WB:     VS 0 ~7&#x000A;    0x10,0x60,0x20,0x00,0x00,0x00,0x00,             #LUT3: WW:     VS 0 ~7&#x000A;    0x00,0x00,0x00,0x00,0x00,0x00,0x00,             #LUT4: VCOM:   VS 0 ~7&#x000A;&#x000A;    0x03,0x03,0x00,0x00,0x02,                       # TP0 A~D RP0&#x000A;    0x09,0x09,0x00,0x00,0x02,                       # TP1 A~D RP1&#x000A;    0x03,0x03,0x00,0x00,0x02,                       # TP2 A~D RP2&#x000A;    0x00,0x00,0x00,0x00,0x00,                       # TP3 A~D RP3&#x000A;    0x00,0x00,0x00,0x00,0x00,                       # TP4 A~D RP4&#x000A;    0x00,0x00,0x00,0x00,0x00,                       # TP5 A~D RP5&#x000A;    0x00,0x00,0x00,0x00,0x00,                       # TP6 A~D RP6&#x000A;&#x000A;    0x15,0x41,0xA8,0x32,0x30,0x0A,&#x000A;]&#x000A;&#x000A;lut_partial_update = [ #20 bytes&#x000A;    0x00,0x00,0x00,0x00,0x00,0x00,0x00,             #LUT0: BB:     VS 0 ~7&#x000A;    0x80,0x00,0x00,0x00,0x00,0x00,0x00,             #LUT1: BW:     VS 0 ~7&#x000A;    0x40,0x00,0x00,0x00,0x00,0x00,0x00,             #LUT2: WB:     VS 0 ~7&#x000A;    0x00,0x00,0x00,0x00,0x00,0x00,0x00,             #LUT3: WW:     VS 0 ~7&#x000A;    0x00,0x00,0x00,0x00,0x00,0x00,0x00,             #LUT4: VCOM:   VS 0 ~7&#x000A;&#x000A;    0x0A,0x00,0x00,0x00,0x00,                       # TP0 A~D RP0&#x000A;    0x00,0x00,0x00,0x00,0x00,                       # TP1 A~D RP1&#x000A;    0x00,0x00,0x00,0x00,0x00,                       # TP2 A~D RP2&#x000A;    0x00,0x00,0x00,0x00,0x00,                       # TP3 A~D RP3&#x000A;    0x00,0x00,0x00,0x00,0x00,                       # TP4 A~D RP4&#x000A;    0x00,0x00,0x00,0x00,0x00,                       # TP5 A~D RP5&#x000A;    0x00,0x00,0x00,0x00,0x00,                       # TP6 A~D RP6&#x000A;&#x000A;    0x15,0x41,0xA8,0x32,0x30,0x0A,&#x000A;]&#x000A;&#x000A;# Hardware reset&#x000A;def reset(self):&#x000A;    epdconfig.digital_write(self.reset_pin, 1)&#x000A;    epdconfig.delay_ms(200) &#x000A;    epdconfig.digital_write(self.reset_pin, 0)&#x000A;    epdconfig.delay_ms(10)&#x000A;    epdconfig.digital_write(self.reset_pin, 1)&#x000A;    epdconfig.delay_ms(200)   &#x000A;&#x000A;def send_command(self, command):&#x000A;    epdconfig.digital_write(self.dc_pin, 0)&#x000A;    epdconfig.digital_write(self.cs_pin, 0)&#x000A;    epdconfig.spi_writebyte([command])&#x000A;    epdconfig.digital_write(self.cs_pin, 1)&#x000A;&#x000A;def send_data(self, data):&#x000A;    epdconfig.digital_write(self.dc_pin, 1)&#x000A;    epdconfig.digital_write(self.cs_pin, 0)&#x000A;    epdconfig.spi_writebyte([data])&#x000A;    epdconfig.digital_write(self.cs_pin, 1)&#x000A;&#x000A;def ReadBusy(self):&#x000A;    while(epdconfig.digital_read(self.busy_pin) == 1):      # 0: idle, 1: busy&#x000A;        epdconfig.delay_ms(100)    &#x000A;&#x000A;def TurnOnDisplay(self):&#x000A;    self.send_command(0x22)&#x000A;    self.send_data(0xC7)&#x000A;    self.send_command(0x20)        &#x000A;    self.ReadBusy()&#x000A;&#x000A;def TurnOnDisplayPart(self):&#x000A;    self.send_command(0x22)&#x000A;    self.send_data(0x0c)&#x000A;    self.send_command(0x20)        &#x000A;    self.ReadBusy()&#x000A;&#x000A;def init(self, update):&#x000A;    if (epdconfig.module_init() != 0):&#x000A;        return -1&#x000A;    # EPD hardware init start&#x000A;    self.reset()&#x000A;    if(update == self.FULL_UPDATE):&#x000A;        self.ReadBusy()&#x000A;        self.send_command(0x12) # soft reset&#x000A;        self.ReadBusy()&#x000A;&#x000A;        self.send_command(0x74) #set analog block control&#x000A;        self.send_data(0x54)&#x000A;        self.send_command(0x7E) #set digital block control&#x000A;        self.send_data(0x3B)&#x000A;&#x000A;        self.send_command(0x01) #Driver output control&#x000A;        self.send_data(0xF9)&#x000A;        self.send_data(0x00)&#x000A;        self.send_data(0x00)&#x000A;&#x000A;        self.send_command(0x11) #data entry mode&#x000A;        self.send_data(0x01)&#x000A;&#x000A;        self.send_command(0x44) #set Ram-X address start/end position&#x000A;        self.send_data(0x00)&#x000A;        self.send_data(0x0F)    #0x0C--&gt;(15+1)*8=128&#x000A;&#x000A;        self.send_command(0x45) #set Ram-Y address start/end position&#x000A;        self.send_data(0xF9)   #0xF9--&gt;(249+1)=250&#x000A;        self.send_data(0x00)&#x000A;        self.send_data(0x00)&#x000A;        self.send_data(0x00)&#x000A;&#x000A;        self.send_command(0x3C) #BorderWavefrom&#x000A;        self.send_data(0x03)&#x000A;&#x000A;        self.send_command(0x2C)     #VCOM Voltage&#x000A;        self.send_data(0x55)    #&#x000A;&#x000A;        self.send_command(0x03)&#x000A;        self.send_data(self.lut_full_update[70])&#x000A;&#x000A;        self.send_command(0x04) #&#x000A;        self.send_data(self.lut_full_update[71])&#x000A;        self.send_data(self.lut_full_update[72])&#x000A;        self.send_data(self.lut_full_update[73])&#x000A;&#x000A;        self.send_command(0x3A)     #Dummy Line&#x000A;        self.send_data(self.lut_full_update[74])&#x000A;        self.send_command(0x3B)     #Gate time&#x000A;        self.send_data(self.lut_full_update[75])&#x000A;&#x000A;        self.send_command(0x32)&#x000A;        for count in range(70):&#x000A;            self.send_data(self.lut_full_update[count])&#x000A;&#x000A;        self.send_command(0x4E)   # set RAM x address count to 0&#x000A;        self.send_data(0x00)&#x000A;        self.send_command(0x4F)   # set RAM y address count to 0X127&#x000A;        self.send_data(0xF9)&#x000A;        self.send_data(0x00)&#x000A;        self.ReadBusy()&#x000A;    else:&#x000A;        self.send_command(0x2C)     #VCOM Voltage&#x000A;        self.send_data(0x26)&#x000A;&#x000A;        self.ReadBusy()&#x000A;&#x000A;        self.send_command(0x32)&#x000A;        for count in range(70):&#x000A;            self.send_data(self.lut_partial_update[count])&#x000A;&#x000A;        self.send_command(0x37)&#x000A;        self.send_data(0x00)&#x000A;        self.send_data(0x00)&#x000A;        self.send_data(0x00)&#x000A;        self.send_data(0x00)&#x000A;        self.send_data(0x40)&#x000A;        self.send_data(0x00)&#x000A;        self.send_data(0x00)&#x000A;&#x000A;        self.send_command(0x22)&#x000A;        self.send_data(0xC0)&#x000A;        self.send_command(0x20)&#x000A;        self.ReadBusy()&#x000A;&#x000A;        self.send_command(0x3C) #BorderWavefrom&#x000A;        self.send_data(0x01)&#x000A;    return 0&#x000A;&#x000A;def getbuffer(self, image):&#x000A;    if self.width%8 == 0:&#x000A;        linewidth = int(self.width/8)&#x000A;    else:&#x000A;        linewidth = int(self.width/8) + 1&#x000A;&#x000A;    buf = [0xFF] * (linewidth * self.height)&#x000A;    image_monocolor = image.convert(&#39;1&#39;)&#x000A;    imwidth, imheight = image_monocolor.size&#x000A;    pixels = image_monocolor.load()&#x000A;&#x000A;    if(imwidth == self.width and imheight == self.height):&#x000A;        logging.debug(&quot;Vertical&quot;)&#x000A;        for y in range(imheight):&#x000A;            for x in range(imwidth):                    &#x000A;                if pixels[x, y] == 0:&#x000A;                    x = imwidth - x&#x000A;                    buf[int(x / 8) + y * linewidth] &amp;= ~(0x80 &gt;&gt; (x % 8))&#x000A;    elif(imwidth == self.height and imheight == self.width):&#x000A;        logging.debug(&quot;Horizontal&quot;)&#x000A;        for y in range(imheight):&#x000A;            for x in range(imwidth):&#x000A;                newx = y&#x000A;                newy = self.height - x - 1&#x000A;                if pixels[x, y] == 0:&#x000A;                    newy = imwidth - newy - 1&#x000A;                    buf[int(newx / 8) + newy*linewidth] &amp;= ~(0x80 &gt;&gt; (y % 8))&#x000A;    return buf   &#x000A;&#x000A;def display(self, image):&#x000A;    if self.width%8 == 0:&#x000A;        linewidth = int(self.width/8)&#x000A;    else:&#x000A;        linewidth = int(self.width/8) + 1&#x000A;&#x000A;    self.send_command(0x24)&#x000A;    for j in range(0, self.height):&#x000A;        for i in range(0, linewidth):&#x000A;            self.send_data(image[i + j * linewidth])   &#x000A;    self.TurnOnDisplay()&#x000A;&#x000A;def displayPartial(self, image):&#x000A;    if self.width%8 == 0:&#x000A;        linewidth = int(self.width/8)&#x000A;    else:&#x000A;        linewidth = int(self.width/8) + 1&#x000A;&#x000A;    self.send_command(0x24)&#x000A;    for j in range(0, self.height):&#x000A;        for i in range(0, linewidth):&#x000A;            self.send_data(image[i + j * linewidth])   &#x000A;&#x000A;    # self.send_command(0x26)&#x000A;    # for j in range(0, self.height):&#x000A;        # for i in range(0, linewidth):&#x000A;            # self.send_data(~image[i + j * linewidth])  &#x000A;    self.TurnOnDisplayPart()&#x000A;&#x000A;def displayPartBaseImage(self, image):&#x000A;    if self.width%8 == 0:&#x000A;        linewidth = int(self.width/8)&#x000A;    else:&#x000A;        linewidth = int(self.width/8) + 1&#x000A;&#x000A;    self.send_command(0x24)&#x000A;    for j in range(0, self.height):&#x000A;        for i in range(0, linewidth):&#x000A;            self.send_data(image[i + j * linewidth])   &#x000A;&#x000A;    self.send_command(0x26)&#x000A;    for j in range(0, self.height):&#x000A;        for i in range(0, linewidth):&#x000A;            self.send_data(image[i + j * linewidth])  &#x000A;    self.TurnOnDisplay()&#x000A;&#x000A;def Clear(self, color):&#x000A;    if self.width%8 == 0:&#x000A;        linewidth = int(self.width/8)&#x000A;    else:&#x000A;        linewidth = int(self.width/8) + 1&#x000A;    # logging.debug(linewidth)&#x000A;&#x000A;    self.send_command(0x24)&#x000A;    for j in range(0, self.height):&#x000A;        for i in range(0, linewidth):&#x000A;            self.send_data(color)   &#x000A;    self.TurnOnDisplay()&#x000A;&#x000A;def sleep(self):&#x000A;    self.send_command(0x10) #enter deep sleep&#x000A;    self.send_data(0x01)&#x000A;    epdconfig.delay_ms(100)&#x000A;&#x000A;    epdconfig.module_exit()</pre>

<p>### END OF FILE ###</p>
</div>
<div id='context'>
</div>

</div>
</div>

<div id='footer-push'></div>
</div>
<div id='footer'>
<a href="https://github.com/rdoc/hanna-nouveau"><strong>Hanna Nouveau</strong> RDoc template</a>
</div>
</body>
</html>
